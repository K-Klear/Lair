local player = require("main/player_info")

local walls = {}

local scale_multiplier = 13
local wall_x = 243
local centre = vmath.vector3(360, 360, 0)

local visible_range = 20
local step_time = 1

local map = {}
local tiles = {}
tiles[1] = {wall = true, texture = hash("wall")}
tiles[3] = {wall = true, texture = hash("wall_red")}

local function load_tilemap()
	map = {}
	map.min_x, map.min_y, map.max_x, map.max_y = tilemap.get_bounds("/minimap#minimap")
	local player_x, player_y
	local found = false
	for _x = map.min_x, map.max_x do
		for _y = map.min_y, map.max_y do
			if tilemap.get_tile("/minimap#minimap", "player", _x, _y) == 5 then
				player_x = _x; player_y = _y; break
			end
		end
		if found then break end
	end
	for _x = map.min_x, map.max_x do
		map[_x - player_x] = {}
		for _y = map.min_y, map.max_y do
			local tile = tilemap.get_tile("/minimap#minimap", "walls", _x, _y)
			if tiles[tile] then
				map[_x - player_x][_y - player_y + 1] = {wall = tiles[tile].wall; texture = tiles[tile].texture}
			end
		end
	end
	map.min_y = map.min_y - player_y + 1; map.max_y = map.max_y - player_y + 1
	map.min_x = map.min_x - player_x; map.max_x = map.max_x - player_x
end

local function move_tilemap()

local function get_x(pos, depth)
	local mod = 0
	local pos_x = 0
	local dist = depth * 2 + 1
	if pos < 0 then mod = 1 end
	for x = 0 + mod, math.abs(pos) - 1 + mod do
		pos_x = pos_x + wall_x * scale_multiplier / dist
	end
	if pos < 0 then pos_x = -pos_x end
	return pos_x - (wall_x * scale_multiplier / dist) / 2 
end

local function wall_front(pos, depth, facing)
	local dist = depth * 2 + 1
	local pos_x = get_x(pos, depth)
	local scale = vmath.vector3(scale_multiplier / dist, scale_multiplier / dist, 1) 
	local distance = math.sqrt(math.abs(pos)^2 + depth^2)
	local position = vmath.vector3(centre.x + pos_x, centre.y, 	0.9 / (distance + 1))
	return position, scale
end

local function wall_left(pos, depth)
	local dist = depth * 2 - 1
	local pos_x = get_x(pos, depth - 1)
	local size = get_x(pos, depth) - pos_x
	if size < 0 then return end
	local scale = vmath.vector3(size / wall_x, scale_multiplier / dist, 1) 
	local distance = math.sqrt(math.abs(pos)^2 + depth^2)
	local position = vmath.vector3(centre.x + pos_x, centre.y, 0.9 / (distance + 1))
	local skew = (1 - (dist / ((depth + 1) * 2 - 1))) / 3
	return position, scale, skew
end

local function wall_right(pos, depth)
	local dist = depth * 2 - 1
	local pos_x = get_x(pos + 1, depth)
	local size = get_x(pos + 1, depth - 1) - pos_x
	if size < 0 then return end
	local scale = vmath.vector3(size / wall_x, scale_multiplier / dist, 1) 
	local distance = math.sqrt(math.abs(pos)^2 + depth^2)
	local position = vmath.vector3(centre.x + pos_x, centre.y, 0.9 / (distance + 1))
	local skew =  (1 - (dist / ((depth + 1) * 2 - 1))) / 3
	return position, scale, skew
end

local function draw_walls()
	for depth = 0, math.min(visible_range, map.max_x) do
		local pos_range = math.ceil((depth + 1) * 0.6) + 1
		for pos = math.max(-pos_range, map.min_x), math.min(pos_range, map.max_x) do
			if map[pos][depth] and map[pos][depth].wall then
				if not map[pos][depth-1] or not map[pos][depth-1].wall then
					if not (depth == 0) or not (pos == 0) then
						local position, scale = wall_front(pos, depth)
						table.insert(walls, {
							go = factory.create("#wall", position, nil, {texture = map[pos][depth].texture}, scale),
							pos = pos,
							depth = depth,
							facing = hash("front")
						})
					end
				end
				if not map[pos-1][depth] or not map[pos-1][depth].wall then
					local position, scale, skew = wall_right(pos-1, depth+1)
					if position then
						table.insert(walls, {
							go = factory.create("#wall", position, nil, {skew_x = skew, texture = map[pos][depth].texture}, scale),
							pos = pos,
							depth = depth,
							facing = hash("right")
						})
					end
				end
				if not map[pos+1][depth] or not map[pos+1][depth].wall then
					local position, scale, skew = wall_left(pos + 1, depth + 1)
					if position then
						table.insert(walls, {
							go = factory.create("#wall", position, nil, {skew_y = skew, texture = map[pos][depth].texture}, scale),
							pos = pos,
							depth = depth,
							facing = hash("left")
						})
					end
				end
			end
		end
	end
end

local function update_view()
	for key, val in ipairs(walls) do
		msg.post(val.go, "delete")
	end
	walls = {}
	draw_walls()
end

local move = {}

function move.forward()
	for key, val in ipairs(walls) do
		local position, scale, skew
		if val.facing == hash("front") then
			position, scale = wall_front(val.pos, val.depth - 1)
		elseif val.facing == hash("left") then
			position, scale, skew = wall_left(val.pos + 1, val.depth)
			if position then
				local skew_real = vmath.vector4(0, skew * scale.y, 0, 0)
				go.animate(msg.url(nil, val.go, "sprite"), "skew", go.PLAYBACK_ONCE_FORWARD, skew_real, go.EASING_LINEAR, step_time)
			end
		elseif val.facing == hash("right") then
			position, scale, skew = wall_right(val.pos - 1, val.depth)
			if position then
				local skew_real = vmath.vector4(skew * scale.y, 0, 0, 0)
				go.animate(msg.url(nil, val.go, "sprite"), "skew", go.PLAYBACK_ONCE_FORWARD, skew_real, go.EASING_LINEAR, step_time)
			end
		end
		if position and val.depth > 0 then
			go.animate(val.go, "position", go.PLAYBACK_ONCE_FORWARD, position, go.EASING_LINEAR, step_time)
			go.animate(val.go, "scale", go.PLAYBACK_ONCE_FORWARD, scale, go.EASING_LINEAR, step_time)
		end
	end
	timer.delay(step_time, false, function() player.moving = false; update_view() end)
end

function move.back()
	for key, val in ipairs(walls) do
		local position, scale, skew
		if val.facing == hash("front") then
			position, scale = wall_front(val.pos, val.depth + 1)
		elseif val.facing == hash("left") then
			position, scale, skew = wall_left(val.pos + 1, val.depth + 2)
			if position then
				local skew_real = vmath.vector4(0, skew * scale.y, 0, 0)
				go.animate(msg.url(nil, val.go, "sprite"), "skew", go.PLAYBACK_ONCE_FORWARD, skew_real, go.EASING_LINEAR, step_time)
			end
		elseif val.facing == hash("right") then
			position, scale, skew = wall_right(val.pos - 1, val.depth + 2)
			if position then
				local skew_real = vmath.vector4(skew * scale.y, 0, 0, 0)
				go.animate(msg.url(nil, val.go, "sprite"), "skew", go.PLAYBACK_ONCE_FORWARD, skew_real, go.EASING_LINEAR, step_time)
			end
		end
		if position then
			go.animate(val.go, "position", go.PLAYBACK_ONCE_FORWARD, position, go.EASING_LINEAR, step_time)
			go.animate(val.go, "scale", go.PLAYBACK_ONCE_FORWARD, scale, go.EASING_LINEAR, step_time)
		end
	end
	timer.delay(step_time, false, function() player.moving = false; update_view() end)
end

function move.left()
	for key, val in ipairs(walls) do
		local position, scale, skew
		if val.facing == hash("front") then
			position, scale = wall_front(val.pos + 1, val.depth)
		elseif val.facing == hash("left") then
			position, scale, skew = wall_left(val.pos + 2, val.depth + 1)
			if position then
				local skew_real = vmath.vector4(0, skew * scale.y, 0, 0)
				go.animate(msg.url(nil, val.go, "sprite"), "skew", go.PLAYBACK_ONCE_FORWARD, skew_real, go.EASING_LINEAR, step_time)
			else
				go.animate(val.go, "scale.x", go.PLAYBACK_ONCE_FORWARD, 0, go.EASING_LINEAR, step_time / 2)
				go.animate(val.go, "position.x", go.PLAYBACK_ONCE_FORWARD, centre.x, go.EASING_LINEAR, step_time / 2)
			end
		elseif val.facing == hash("right") then
			position, scale, skew = wall_right(val.pos, val.depth + 1)
			if position then
				local skew_real = vmath.vector4(skew * scale.y, 0, 0, 0)
				go.animate(msg.url(nil, val.go, "sprite"), "skew", go.PLAYBACK_ONCE_FORWARD, skew_real, go.EASING_LINEAR, step_time)
			end
		end
		if position then
			go.animate(val.go, "position", go.PLAYBACK_ONCE_FORWARD, position, go.EASING_LINEAR, step_time)
			go.animate(val.go, "scale", go.PLAYBACK_ONCE_FORWARD, scale, go.EASING_LINEAR, step_time)
		end
	end
	for depth = 0, math.min(visible_range, y_size - player.y - 1) do
		local tile = tilemap.get_tile("/minimap#minimap", "walls", player.x + 1, depth + player.y - 1)
		if tiles[tile].wall == true then
			local tile_left = tilemap.get_tile("/minimap#minimap", "walls", player.x, depth + player.y - 1)
			if tile_left and not tiles[tile_left].wall then
				local position, scale, skew = wall_right(0, depth + 1)
				if position then
					table.insert(walls, {
						go = factory.create("#wall", vmath.vector3(centre.x, position.y, position.z), nil, {skew_x = skew, texture = tiles[tile].texture}, vmath.vector3(0, scale.y, scale.z)),
						pos = 0,
						depth = depth,
						facing = hash("right")
					})
					go.animate(walls[#walls].go, "scale.x", go.PLAYBACK_ONCE_FORWARD, scale.x, go.EASING_LINEAR, step_time / 2, step_time / 2)
					go.animate(walls[#walls].go, "position.x", go.PLAYBACK_ONCE_FORWARD, position.x, go.EASING_LINEAR, step_time / 2, step_time / 2)
				end
			end
		end
	end
	timer.delay(step_time, false, function() player.moving = false; update_view() end)
end

function move.right()
	for key, val in ipairs(walls) do
		local position, scale, skew
		if val.facing == hash("front") then
			position, scale = wall_front(val.pos - 1, val.depth)
		elseif val.facing == hash("left") then
			position, scale, skew = wall_left(val.pos, val.depth + 1)
			if position then
				local skew_real = vmath.vector4(0, skew * scale.y, 0, 0)
				go.animate(msg.url(nil, val.go, "sprite"), "skew", go.PLAYBACK_ONCE_FORWARD, skew_real, go.EASING_LINEAR, step_time)
			end
		elseif val.facing == hash("right") then
			position, scale, skew = wall_right(val.pos - 2, val.depth + 1)
			if position then
				local skew_real = vmath.vector4(skew * scale.y, 0, 0, 0)
				go.animate(msg.url(nil, val.go, "sprite"), "skew", go.PLAYBACK_ONCE_FORWARD, skew_real, go.EASING_LINEAR, step_time)
			else
				go.animate(val.go, "scale.x", go.PLAYBACK_ONCE_FORWARD, 0, go.EASING_LINEAR, step_time / 2)
				go.animate(val.go, "position.x", go.PLAYBACK_ONCE_FORWARD, centre.x, go.EASING_LINEAR, step_time / 2)
			end
		end
		if position then
			go.animate(val.go, "position", go.PLAYBACK_ONCE_FORWARD, position, go.EASING_LINEAR, step_time)
			go.animate(val.go, "scale", go.PLAYBACK_ONCE_FORWARD, scale, go.EASING_LINEAR, step_time)
		end
	end
	for depth = 0, math.min(visible_range, y_size - player.y - 1) do
		local tile = tilemap.get_tile("/minimap#minimap", "walls", player.x - 1, depth + player.y - 1)
		if tiles[tile].wall == true then
			local tile_right = tilemap.get_tile("/minimap#minimap", "walls", player.x, depth + player.y - 1)
			if tile_right and not tiles[tile_right].wall then
				local position, scale, skew = wall_left(0, depth + 1)
				if position then
					table.insert(walls, {
						go = factory.create("#wall", vmath.vector3(centre.x, position.y, position.z), nil, {skew_y = skew, texture = tiles[tile].texture}, vmath.vector3(0, scale.y, scale.z)),
						pos = 0,
						depth = depth,
						facing = hash("left")
					})
					go.animate(walls[#walls].go, "scale.x", go.PLAYBACK_ONCE_FORWARD, scale.x, go.EASING_LINEAR, step_time / 2, step_time / 2)
					go.animate(walls[#walls].go, "position.x", go.PLAYBACK_ONCE_FORWARD, position.x, go.EASING_LINEAR, step_time / 2, step_time / 2)
				end
			end
		end
	end
	timer.delay(step_time, false, function() player.moving = false; update_view() end)
end


function init(self)
	map.min_x, map.min_y, map.max_x, map.max_y = tilemap.get_bounds("/minimap#minimap")
	load_tilemap()
	update_view()
end

function on_message(self, message_id, message, sender)
	if message_id == hash("update") then
		update_view()
	elseif message_id == hash("forward") then
		move.forward()
	elseif message_id == hash("back") then
		move.back()
	elseif message_id == hash("left") then
		move.left()
	elseif message_id == hash("right") then
		move.right()
	end
end

function on_input(self, action_id, action)
	
end




