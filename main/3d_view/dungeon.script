local player = require("main/player_info")
local screen_size = require("main/3d_view/screen_size")

local walls = {}

local wall_x = 512						-- change if I want to change wall texture size for some reason
local scale_multiplier = 4120 / wall_x	
local skew_divisor = 2 				--no idea what the number represents, to be honest

local centre = vmath.vector3(640, 624, 0)

local render_range = 20

local map = {}
local map_bounds = {}
local tiles = {}
tiles[1] = {wall = true, texture = "#wall", health = 20}
tiles[2] = {wall = true, texture = "#dirt", health = 10}
tiles[3] = {wall = true, texture = "#wall_red", health = 20}


local function load_tilemap()
	map = {}
	map_bounds.min_x, map_bounds.min_y, map_bounds.max_x, map_bounds.max_y = tilemap.get_bounds("/minimap#minimap")
	local player_x, player_y	-- find starting location
	local found = false
	for _x = map_bounds.min_x, map_bounds.max_x do
		for _y = map_bounds.min_y, map_bounds.max_y do
			if tilemap.get_tile("/minimap#minimap", "player", _x, _y) == 5 then
				player_x = _x; player_y = _y; break
			end
		end
		if found then break end
	end
	for _x = map_bounds.min_x, map_bounds.max_x do
		map[_x - player_x] = {}
		for _y = map_bounds.min_y, map_bounds.max_y do
			local tile = tilemap.get_tile("/minimap#minimap", "walls", _x, _y)
			if tiles[tile] then
				map[_x - player_x][_y - player_y + 1] = {wall = tiles[tile].wall; texture = tiles[tile].texture; health = tiles[tile].health, health_max = tiles[tile].health}
			end
		end
	end
	map_bounds.min_y = map_bounds.min_y - player_y + 1; map_bounds.max_y = map_bounds.max_y - player_y + 1
	map_bounds.min_x = map_bounds.min_x - player_x; map_bounds.max_x = map_bounds.max_x - player_x
end

local function wall(pos, depth, facing)
	local dist = depth * 2 + 1
	local x_offset, scale_y, scale, skew
	local shade = 1 - (depth - 1) * player.sight_range
	if facing == 0 then
		x_offset = pos * scale_multiplier * wall_x / dist
		scale = vmath.vector3(scale_multiplier / dist, scale_multiplier / dist, 1)
		shade = vmath.vector4(shade, shade, 1, 1)
		skew = vmath.vector4(0, 0, 0, 0)
	else
		scale_y = -scale_multiplier * (-2 * math.abs(pos) - 1) / (dist^2 + 2 * dist)
		scale = vmath.vector3(scale_y, scale_multiplier / dist, 1)
		if facing > 0 then
			x_offset = -scale_multiplier * wall_x * (-pos * dist - pos - dist * 0.5 - 0.5) / (dist^2 + 2 * dist)
			skew = vmath.vector4((1 - dist / (dist + 2)) / skew_divisor, 0, 0, 0) * scale.y
			shade = vmath.vector4(shade, shade + player.sight_range, 1, 1)
		else
			x_offset = scale_multiplier * wall_x * (pos * dist + pos - dist * 0.5 - 0.5) / (dist^2 + 2 * dist)
			skew = vmath.vector4(0, (1 - dist / (dist + 2)) / skew_divisor, 0, 0) * scale.y
			shade = vmath.vector4(shade + player.sight_range, shade, 1, 1)
		end
	end
	local distance = math.sqrt(math.abs(pos)^2 + depth^2)
	local position = vmath.vector3(centre.x + x_offset, centre.y, 0.9 / (distance + 1))
	return position, scale, shade, skew
end

local function wall_create(pos, depth, facing, position, scale, shade, skew)
	local props = {shade = shade, skew = skew, health = map[pos][depth].health, health_max = map[pos][depth].health_max}
	local texture = map[pos][depth].texture
	table.insert(walls, {go = factory.create(texture, position, nil, props, scale), pos = pos, depth = depth, facing = facing})
end

local function update_view()
	for key, val in ipairs(walls) do
		msg.post(val.go, "delete")
	end
	walls = {}
	for depth = 0, math.min(render_range, map_bounds.max_y) do
		local pos_range = math.ceil((depth + 1) * 0.6) + 1
		for pos = math.max(-pos_range, map_bounds.min_x), math.min(pos_range, map_bounds.max_x) do
			if map[pos][depth] and map[pos][depth].wall then
				if not map[pos][depth-1] or not map[pos][depth-1].wall then
					if not (depth == 0) or not (pos == 0) then
						local position, scale, shade = wall(pos, depth, 0)
						wall_create(pos, depth, 0, position, scale, shade, skew)
					end
				end
				if pos > 0 and (not map[pos-1][depth] or not map[pos-1][depth].wall) then
					local position, scale, shade, skew = wall(pos-1, depth, 1)
					wall_create(pos, depth, 1, position, scale, shade, skew)
				end
				if pos < 0 and (not map[pos+1][depth] or not map[pos+1][depth].wall) then
					local position, scale, shade, skew = wall(pos+1, depth, -1)
					wall_create(pos, depth, -1, position, scale, shade, skew)
				end
			end
		end
	end
end

local function move_tilemap(dir)
	local direction = {up = {x = 0, y = -1}, down = {x = 0, y = 1},	left = {x = 1, y = 0}, right = {x = -1, y = 0}}
	local map_old = map
	map = {}
	for x = map_bounds.min_x, map_bounds.max_x do
		map[x + direction[dir].x] = {}
		for y = map_bounds.min_y, map_bounds.max_y do
			map[x + direction[dir].x][y + direction[dir].y] = map_old[x][y]
		end
	end
	for key, val in ipairs(walls) do
		val.pos = val.pos + direction[dir].x
		val.depth = val.depth + direction[dir].y
	end
	map_bounds.min_y = map_bounds.min_y + direction[dir].y; map_bounds.max_y = map_bounds.max_y + direction[dir].y
	map_bounds.min_x = map_bounds.min_x + direction[dir].x; map_bounds.max_x = map_bounds.max_x + direction[dir].x
end

local function turn_tilemap(left)
	local shift_x, shift_y
	if left then
		shift_x, shift_y = 1, map_bounds.max_x + map_bounds.min_x - 1
	else
		shift_x, shift_y = map_bounds.max_y + map_bounds.min_y - 1, -1
	end
	local map_old = map
	map = {}
	for y = map_bounds.min_y, map_bounds.max_y do map[y - shift_x] = {} end
	for x = map_bounds.min_x, map_bounds.max_x do
		for y = map_bounds.min_y, map_bounds.max_y do
			if left then
				map[y - shift_x][map_bounds.max_x - (x - map_bounds.min_x) - shift_y] = map_old[x][y]
			else
				map[map_bounds.max_y - (y - map_bounds.min_y) - shift_x][x - shift_y] = map_old[x][y]
			end
		end
	end
	local min_x, max_x, min_y, max_y = map_bounds.min_x, map_bounds.max_x, map_bounds.min_y, map_bounds.max_y
	map_bounds.min_y = min_x - shift_y; map_bounds.max_y = max_x - shift_y
	map_bounds.min_x = min_y - shift_x; map_bounds.max_x = max_y - shift_x
	update_view()
end

local function move(forward)
	for key, val in ipairs(walls) do
		if val.depth > -1 then
			local position, scale, shade, skew = wall(val.pos - val.facing, val.depth, val.facing)
			msg.post(val.go, hash("skew"), {skew = skew})
			go.animate(val.go, "position", go.PLAYBACK_ONCE_FORWARD, position, go.EASING_LINEAR, player.step_time)
			go.animate(val.go, "scale", go.PLAYBACK_ONCE_FORWARD, scale, go.EASING_LINEAR, player.step_time)
			if forward then
				msg.post(val.go, hash("shade_plus"))
			else
				msg.post(val.go, hash("shade_minus"))
			end
		end
	end
	timer.delay(player.step_time, false, function() player.moving = false; update_view() end)
end

local function move_side(side)
	for key, val in ipairs(walls) do
		if val.depth > 0 then
			if val.pos == 0 and val.facing == side then
				go.animate(val.go, "scale.x", go.PLAYBACK_ONCE_FORWARD, 0, go.EASING_LINEAR, player.step_time / 2)
				go.animate(val.go, "position.x", go.PLAYBACK_ONCE_FORWARD, centre.x, go.EASING_LINEAR, player.step_time / 2)
			else
				local position, scale, shade, skew = wall(val.pos - val.facing, val.depth, val.facing)
				msg.post(val.go, hash("skew"), {skew = skew})
				go.animate(val.go, "position", go.PLAYBACK_ONCE_FORWARD, position, go.EASING_LINEAR, player.step_time)
				go.animate(val.go, "scale", go.PLAYBACK_ONCE_FORWARD, scale, go.EASING_LINEAR, player.step_time)
			end
		end
	end
	for depth = 0, math.min(render_range, map_bounds.max_y) do
		if map[-side][depth] and map[-side][depth].wall then
			if not map[0][depth] or not map[0][depth].wall then
				if depth > 0 then
					local position, scale, shade, skew = wall(0, depth, -side)
					wall_create(-side, depth, 1, vmath.vector3(centre.x, position.y, position.z), vmath.vector3(0, scale.y, scale.z), shade, skew)
					go.animate(walls[#walls].go, "scale.x", go.PLAYBACK_ONCE_FORWARD, scale.x, go.EASING_LINEAR, player.step_time / 2, player.step_time / 2)
					go.animate(walls[#walls].go, "position.x", go.PLAYBACK_ONCE_FORWARD, position.x, go.EASING_LINEAR, player.step_time / 2, player.step_time / 2)
				end
			end
		end
	end
	timer.delay(player.step_time, false, function() player.moving = false; update_view() end)
end

local function window_callback(self, event, data)
	if event == window.WINDOW_EVENT_FOCUS_LOST then
	
	elseif event == window.WINDOW_EVENT_FOCUS_GAINED then
	
	elseif event == window.WINDOW_EVENT_RESIZED then
		screen_size.x, screen_size.y = data.width, data.height
	end
end

function init(self)
	msg.post("@render:", "use_fixed_fit_projection", {near = -1, far = 1})
	window.set_listener(window_callback)
	map_bounds.min_x, map_bounds.min_y, map_bounds.max_x, map_bounds.max_y = tilemap.get_bounds("/minimap#minimap")
	load_tilemap()
	update_view()
end

function on_message(self, message_id, message, sender)
	if message_id == hash("update") then
		update_view()
	elseif message_id == hash("forward") then
		if not map[0][2] or not map[0][2].wall then
			move_tilemap("up")
			move(true)
		else
			player.moving = false
		end
	elseif message_id == hash("back") then
		if not map[0][0] or not map[0][0].wall then
			move_tilemap("down")
			move(false)
		else
			player.moving = false
		end
	elseif message_id == hash("left") then
		if not map[-1][1] or not map[-1][1].wall then
			move_tilemap("left")
			move_side(-1)
		else
			player.moving = false
		end
	elseif message_id == hash("right") then
		if not map[1][1] or not map[1][1].wall then
			move_tilemap("right")
			move_side(1)
		else
			player.moving = false
		end
	elseif message_id == hash("turn_left") then
		turn_tilemap(true)
	elseif message_id == hash("turn_right") then
		turn_tilemap(false)
	elseif message_id == hash("space") then
		msg.post("/weapon", hash("fire"))
	elseif message_id == hash("weapon_hit") then
		if map[0][2] and map[0][2].wall then
			map[0][2].health = map[0][2].health - 5
			if map[0][2].health < 1 then
				map[0][2] = nil
			end
			update_view()
		end
	elseif message_id == hash("screen_size") then
		screen_size.x = message.width; screen_size.y = message.height
	end
end