local screen_size = require("main/3d_view/screen_size")
local player = require("main/player_info")
local map = require("main/map/map")
local entities = require("main/entities")
local wall_stats = require("main/map/wall_stats")
local F = require("main/functions")

local clock_timer

local function time()
	player.time = player.time + 1
	msg.post("/hud#hud", hash("update_clock"))
end

function init(self)
	math.randomseed(os.time()); math.random(); math.random(); math.random()
	msg.post(".", "acquire_input_focus")
	msg.post("/hud#hud", hash("update_compass"))
	msg.post("/hud#hud", hash("update_clock"))
	clock_timer = timer.delay(1, true, time)
end

local function test_spawn()
	local x, y = F.position_to_coords(0, 2)
	--table.insert(entities.actors, {id = entities.actors.id, x = x, y = y, type = "zombie", facing = "S", speed = 0.6, local_x = 0, local_y = 0})
	--entities.actors.id = entities.actors.id + 1
	--table.insert(entities.objects, {id = entities.objects.id, x = x, y = y, type = "stalagtite", local_x = 0, local_y = 0, ceiling = true})
	--entities.objects.id = entities.objects.id + 1
	table.insert(entities.objects, {
		id = entities.objects.id, x = x, y = y, type = "slab", local_x = 0, local_y = 0, facing = "S"
	})
	entities.objects.id = entities.objects.id + 1
	--[[
	table.insert(entities.items, {id = entities.items.id, x = x, y = y, type = "stone", local_x = -0.5, local_y = -0.5, local_z = 0})
	entities.items.id = entities.items.id + 1
	table.insert(entities.items, {id = entities.items.id, x = x, y = y, type = "stone", local_x = 0.0, local_y = 0, local_z = 0})
	entities.items.id = entities.items.id + 1
	table.insert(entities.items, {id = entities.items.id, x = x, y = y, type = "stone", local_x = 0.5, local_y = 0.5, local_z = 0})
	entities.items.id = entities.items.id + 1
	--]]
end

function on_input(self, action_id, action)
	if action_id == hash("up") and not player.moving then
		local x, y = F.position_to_coords(0, 2)
		if map[x] and map[x][y] and not map[x][y].wall then
			player.moving = true
			if player.facing == "N" then
				player.y = player.y + 1
			elseif player.facing == "W" then
				player.x = player.x - 1
			elseif player.facing == "S" then
				player.y = player.y - 1
			elseif player.facing == "E" then
				player.x = player.x + 1
			end
			msg.post("/main_view", hash("forward"))
			timer.delay(player.step_time, false, function() msg.post("/minimap", hash("update")) end)
		end
	elseif action_id == hash("down") and not player.moving then
		local x, y = F.position_to_coords(0, 0)
		if map[x] and map[x][y] and not map[x][y].wall then
			player.moving = true
			if player.facing == "N" then
				player.y = player.y - 1
			elseif player.facing == "W" then
				player.x = player.x + 1
			elseif player.facing == "S" then
				player.y = player.y + 1
			elseif player.facing == "E" then
				player.x = player.x - 1
			end
			msg.post("/main_view", hash("back"))
			timer.delay(player.step_time, false, function() msg.post("/minimap", hash("update")) end)
		end
	elseif action_id == hash("slide_left") and not player.moving then
		local x, y = F.position_to_coords(-1, 1)
		if map[x] and map[x][y] and not map[x][y].wall then
			player.moving = true
			if player.facing == "N" then
				player.x = player.x - 1
			elseif player.facing == "W" then
				player.y = player.y - 1
			elseif player.facing == "S" then
				player.x = player.x + 1
			elseif player.facing == "E" then
				player.y = player.y + 1
			end
			msg.post("/main_view", hash("left"))
			timer.delay(player.step_time, false, function() msg.post("/minimap", hash("update")) end)
		end
	elseif action_id == hash("slide_right") and not player.moving then
		local x, y = F.position_to_coords(1, 1)
		if map[x] and map[x][y] and not map[x][y].wall then
			player.moving = true
			if player.facing == "N" then
				player.x = player.x + 1
			elseif player.facing == "W" then
				player.y = player.y + 1
			elseif player.facing == "S" then
				player.x = player.x - 1
			elseif player.facing == "E" then
				player.y = player.y - 1
			end
			msg.post("/main_view", hash("right"))
			timer.delay(player.step_time, false, function() msg.post("/minimap", hash("update")) end)
		end
	elseif action_id == hash("turn_left") and not player.moving and action.pressed then
		player.facing = F.clockwise_rev[F.clockwise[player.facing] - 1] or F.clockwise_rev[4]
		msg.post("/main_view", hash("update"))
		msg.post("/minimap", hash("update"))
		msg.post("/hud#hud", hash("update_compass"))
	elseif action_id == hash("turn_right") and not player.moving and action.pressed then
		player.facing = F.clockwise_rev[F.clockwise[player.facing] + 1] or F.clockwise_rev[1]
		msg.post("/main_view", hash("update"))
		msg.post("/minimap", hash("update"))
		msg.post("/hud#hud", hash("update_compass"))
	elseif action_id == hash("space") then
		msg.post("/weapon", hash("fire"))
	elseif action_id == hash("o") and action.pressed then
		test_spawn()
		msg.post("/main_view", hash("update"))
	elseif action_id == hash("p") and action.pressed then
		msg.post("/main_view", hash("update"))
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("weapon_hit") then
		local x, y = F.position_to_coords(0, 2)
		if map[x] and map[x][y].wall then
			map[x][y].health = map[x][y].health - 5
			if map[x][y].health < 1 then
				msg.post("/minimap", hash("break_wall"), {x = x, y = y})
				if wall_stats[map[x][y].type].debris then
					for debris_type, debris_val in pairs(wall_stats[map[x][y].type].debris) do
						if debris_val.chance > math.random() then
							for count = 1, math.random(1, debris_val.max) do
								table.insert(entities.items, {id = entities.items.id, x = x, y = y, type = debris_type, local_x = math.random() - 0.5, local_y = math.random() - 0.5, local_z = 0})
								entities.items.id = entities.items.id + 1
							end
						end
					end
				end
			end
			msg.post("/main_view", hash("update"))
		end
	end
end